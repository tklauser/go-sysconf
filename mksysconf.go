// Copyright 2018 Tobias Klauser. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"os/exec"
	"regexp"
	"runtime"
	"strings"
)

func gensysconf(in, out, goos, goarch string) error {
	if _, err := os.Stat(in); err != nil {
		if os.IsNotExist(err) {
			return nil
		} else {
			return err
		}
	}

	cmd := exec.Command("go", "tool", "cgo", "-godefs", in)
	defer os.RemoveAll("_obj")
	b, err := cmd.CombinedOutput()
	if err != nil {
		fmt.Fprintln(os.Stderr, string(b))
		return err
	}

	goBuild := goos
	if goarch != "" {
		goBuild = fmt.Sprintf("%s && %s", goos, goarch)
	}

	r := fmt.Sprintf(`$1

//go:build %s`, goBuild)
	cgoCommandRegex := regexp.MustCompile(`(cgo -godefs .*)`)
	b = cgoCommandRegex.ReplaceAll(b, []byte(r))

	b, err = format.Source(b)
	if err != nil {
		return err
	}
	return os.WriteFile(out, b, 0644)
}

func genvarmap(in, out string) error {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, in, nil, 0)
	if err != nil {
		return err
	}

	var b bytes.Buffer
	b.Write([]byte(`
// Code generated by go run mksysconf.go; DO NOT EDIT

package sysconf

func allNames() map[string]int {
	return map[string]int{
`))
	for _, decl := range f.Decls {
		switch d := decl.(type) {
		case *ast.GenDecl:
			for _, spec := range d.Specs {
				switch s := spec.(type) {
				case *ast.ValueSpec:
					for i, id := range s.Names {
						if id.Obj.Kind == ast.Con && strings.HasPrefix(id.Name, "SC_") {
							switch v := s.Values[i].(type) {
							case *ast.BasicLit:
								fmt.Fprintf(&b, "%q: %s,\n", id.Name, v.Value)
							}
						}
					}
				}
			}
		}
	}
	b.Write([]byte("}\n}"))

	buf, err := format.Source(b.Bytes())
	if err != nil {
		return err
	}

	return os.WriteFile(out, buf, 0644)
}

func errExit(err error) {
	fmt.Fprintln(os.Stderr, err)
	os.Exit(1)
}

func main() {
	goos := os.Getenv("GOOS_TARGET")
	if goos == "" {
		goos = runtime.GOOS
		if goos == "illumos" {
			goos = "solaris"
		}
	}
	defs := fmt.Sprintf("sysconf_defs_%s.go", goos)
	zdefs := "z" + defs
	if err := gensysconf(defs, zdefs, goos, ""); err != nil {
		errExit(err)
	}

	vals := fmt.Sprintf("sysconf_values_%s.go", goos)
	// sysconf variable values are GOARCH-specific, thus write per GOARCH
	zvals := fmt.Sprintf("zsysconf_values_%s_%s.go", goos, runtime.GOARCH)
	if err := gensysconf(vals, zvals, goos, goarch); err != nil {
		errExit(err)
	}

	zvarmap := fmt.Sprintf("zsysconf_varmap_%s.go", goos)
	if err := genvarmap(zdefs, zvarmap); err != nil {
		errExit(err)
	}
}
